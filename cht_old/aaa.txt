Microsoft Windows [Version 10.0.17763.316]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Users\NTC>ssh -4 172.30.1.12

C:\Users\NTC>ssh -4 root@172.30.1.12

C:\Users\NTC>ssh -4 root@172.30.1.12
ssh: connect to host 172.30.1.12 port 22: Connection timed out

C:\Users\NTC>ssh -4 root@172.30.1.12
ssh: connect to host 172.30.1.12 port 22: Connection timed out

C:\Users\NTC>ssh -4 root@172.30.1.54

C:\Users\NTC>ssh -4 root@172.30.1.12
ssh: connect to host 172.30.1.12 port 22: Connection timed out

C:\Users\NTC>ssh 172.30.1.12
ssh: connect to host 172.30.1.12 port 22: Connection timed out

C:\Users\NTC>ssh 172.30.1.54
ssh: connect to host 172.30.1.54 port 22: Connection timed out

C:\Users\NTC>ipconfig

Windows IP 구성


이더넷 어댑터 이더넷 2:

   미디어 상태 . . . . . . . . : 미디어 연결 끊김
   연결별 DNS 접미사. . . . : netis

무선 LAN 어댑터 로컬 영역 연결* 11:

   미디어 상태 . . . . . . . . : 미디어 연결 끊김
   연결별 DNS 접미사. . . . :

무선 LAN 어댑터 로컬 영역 연결* 12:

   미디어 상태 . . . . . . . . : 미디어 연결 끊김
   연결별 DNS 접미사. . . . :

무선 LAN 어댑터 Wi-Fi 2:

   연결별 DNS 접미사. . . . :
   링크-로컬 IPv6 주소 . . . . : fe80::a9d8:4da6:a38a:94e5%14
   IPv4 주소 . . . . . . . . . : 192.168.0.3
   서브넷 마스크 . . . . . . . : 255.255.255.0
   기본 게이트웨이 . . . . . . : 192.168.0.1

C:\Users\NTC>ssh -4 root@192.168.0.3
ssh: connect to host 192.168.0.3 port 22: Connection refused

C:\Users\NTC>ssh 192.168.0.3
ssh: connect to host 192.168.0.3 port 22: Connection refused

C:\Users\NTC>ssh 192.168.0.1
ntc@192.168.0.1's password:

C:\Users\NTC>ssh -4 gwadmin@192.168.0.1
gwadmin@192.168.0.1's password:
Permission denied, please try again.
gwadmin@192.168.0.1's password:
Permission denied, please try again.
gwadmin@192.168.0.1's password:
Nexturecom-AICN:~$ cat /opt/iotgw/
.git/                     backends/                 cmd_res.txt               gwsensor.py               node_modules/             package.json
.gitignore                cc_config.ajr             data_processor.py         handlers/                 ntcdb.py                  requirements.txt
.vscode/                  cc_config.json            dev_helpers/              iotgw_logger.py           ntclog.py                 scripts/
NTCReceiver.py            cc_config.test            example.py                iotgw_logger.pyc          ntclog.sh                 simulator/
README.md                 cloud.py                  example_socket_listen.py  logs/                     ntclog_old.py             version.py
__init__.py               cloud_connector.js        gw.conf                   message_forwarder.py      package-lock.json         wirepas_adapter.py
Nexturecom-AICN:~$ cat /opt/iotgw/ntclog.py
'''
    EXAMPLE_READING_SOCKET_DATA.PY

    Copyright (c) 2018, Treon, All rights reserved.
'''

import zmq
import Queue
import threading
import sys
import json
from pprint import pprint
import datetime
import pymysql
import socket
import struct, time

class SocketConnection(threading.Thread):

    def __init__(self,view_cont,conf_data):
        threading.Thread.__init__(self)
        self.active = True
        self.options = view_cont
        self.topic_filter = conf_data['topic_filters']
Mem: 175692K used, 848684K free, 336K shrd, 8304K buff, 64408K cached
CPU:  20% usr  10% sys   0% nic  67% idle   0% io   0% irq   0% sirq
Load average: 0.31 0.42 0.37 1/108 6239
  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND
 1378     1 root     S    86512   8%  29% python wirepas_adapter.py
 5681  2716 gwadmin  R     3188   0%   1% top
 1283  1278 root     S     2824   0%   1% /bin/sh app_led_control.sh
 2445     2 root     IW       0   0%   1% [kworker/u2:3]
 2715  2635 gwadmin  S     4908   0%   0% sshd: gwadmin@pts/0
    5     2 root     IW       0   0%   0% [kworker/u2:0]
  769     2 root     SW       0   0%   0% [irq/61-wl18xx]
  608     2 root     IW       0   0%   0% [kworker/0:2]
    7     2 root     SW       0   0%   0% [ksoftirqd/0]
 1258   996 mysql    S     291m  29%   0% /usr/sbin/mysqld --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib/plugin --user=mysql --log-error=/var/log/mysqld.err --pid-file=/var/lib/my
 1516     1 root     S    76228   7%   0% python cloud.py -n HttpAdapter
 1331     1 root     S    75332   7%   0% python data_processor.py -n WpLogic
 1296     1 root     S    71532   7%   0% node server.js
 1329     1 root     S    49584   5%   0% python message_forwarder.py -f MeshForwarder -c gw.conf
 1330     1 root     S    49584   5%   0% python message_forwarder.py -f CloudForwarder -c gw.conf
 1306     1 root     S    27032   3%   0% python led_state.py
  709     1 root     S    10412   1%   0% /sbin/udevd -d
  889     1 root     S     9316   1%   0% /usr/sbin/wpa_supplicant -u
  862     1 root     S     9016   1%   0% /usr/sbin/connmand
 1460     1 root     S     5420   1%   0% /usr/sbin/ofonod
 2635   922 root     S     4908   0%   0% sshd: gwadmin [priv]
  922     1 root     S     4908   0%   0% /usr/sbin/sshd
 1288  1286 root     S     4492   0%   0% perl -nle $|=1; system("rmmod musb-dsps; rmmod musb-hdrc; modprobe musb-hdrc; modprobe musb-dsps") if (/VBUS_ERROR in a_wait_vrise/)
  969     1 nobody   S <   4488   0%   0% /usr/sbin/gpsd -F /var/run/gpsd.sock -P /var/run/gpsd.pid
  933     1 root     S     4384   0%   0% /usr/libexec/bluetooth/bluetoothd
  952     1 avahi    S     3764   0%   0% avahi-daemon: running [Nexturecom-AICN.local]
  953   952 avahi    S     3764   0%   0% avahi-daemon: chroot helper
 2716  2715 gwadmin  S     3412   0%   0% -bash
  859     1 messageb S     3336   0%   0% /usr/bin/dbus-daemon --system
 1275     1 root     S     3088   0%   0% /usr/sbin/crond
 1278  1275 root     S     3088   0%   0% {crond} /usr/sbin/CROND
 1280  1275 root     S     3088   0%   0% {crond} /usr/sbin/CROND
 1281  1275 root     S     3088   0%   0% {crond} /usr/sbin/CROND
  996     1 root     S     2956   0%   0% {mysqld_safe} /bin/sh /usr/bin/mysqld_safe --datadir=/var/lib/mysql --pid-file=/var/lib/mysql/mysqld.pid
 1285  1280 root     S     2824   0%   0% /bin/sh nbiot_connection.sh
 1332     1 root     S     2824   0%   0% {start_getty} /bin/sh /bin/start_getty 115200 ttyO0 vt102
 1286  1281 root     S     2824   0%   0% /bin/sh -c /bin/dmesg -w | perl -nle '$|=1; system("rmmod musb-dsps; rmmod musb-hdrc; modprobe musb-hdrc; modprobe musb-dsps") if (/VBUS_ERROR in a_wait_
  943     1 root     S     2724   0%   0% /sbin/syslogd -n -O /var/log/messages
  946     1 root     S     2724   0%   0% /sbin/klogd -n
 1333     1 root     S     2724   0%   0% /sbin/getty 38400 tty1
 1362  1332 root     S     2724   0%   0% /sbin/getty -L 115200 ttyO0 vt102
 1287  1286 root     S     2184   0%   0% /bin/dmesg -w
 1272     1 root     S     1956   0%   0% /usr/local/bin//gpio-watch 72:both
    1     0 root     S     1716   0%   0% init [5]
 6179  1285 root     S     1716   0%   0% sleep 20
 6239  1283 root     S     1716   0%   0% sleep 1
  153     2 root     IW       0   0%   0% [kworker/u2:2]
Nexturecom-AICN:~$ cat /opt/iotgw/ntclog.py
'''
    EXAMPLE_READING_SOCKET_DATA.PY

    Copyright (c) 2018, Treon, All rights reserved.
'''

import zmq
import Queue
import threading
import sys
import json
from pprint import pprint
import datetime
import pymysql
import socket
import struct, time

class SocketConnection(threading.Thread):

    def __init__(self,view_cont,conf_data):
        threading.Thread.__init__(self)
        self.active = True
        self.options = view_cont
        self.topic_filter = conf_data['topic_filters']
Mem: 175744K used, 848632K free, 340K shrd, 8304K buff, 64412K cached
CPU:  21% usr  13% sys   0% nic  65% idle   0% io   0% irq   0% sirq
Load average: 0.23 0.39 0.36 1/107 6665
  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND
 1378     1 root     S    86768   8%  31% python wirepas_adapter.py
 6525  2716 gwadmin  R     3188   0%   1% top
 1283  1278 root     S     2824   0%   1% /bin/sh app_led_control.sh
 2445     2 root     IW       0   0%   1% [kworker/u2:3]
 2715  2635 gwadmin  S     4908   0%   0% sshd: gwadmin@pts/0
    5     2 root     IW       0   0%   0% [kworker/u2:0]
  769     2 root     SW       0   0%   0% [irq/61-wl18xx]
  862     1 root     S     9016   1%   0% /usr/sbin/connmand
  608     2 root     IW       0   0%   0% [kworker/0:2]
    7     2 root     SW       0   0%   0% [ksoftirqd/0]
 1258   996 mysql    S     291m  29%   0% /usr/sbin/mysqld --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib/plugin --user=mysql --log-error=/var/log/mysqld.err --pid-file=/var/lib/my
 1516     1 root     S    76228   7%   0% python cloud.py -n HttpAdapter
 1331     1 root     S    75332   7%   0% python data_processor.py -n WpLogic
 1296     1 root     S    71532   7%   0% node server.js
 1329     1 root     S    49584   5%   0% python message_forwarder.py -f MeshForwarder -c gw.conf
 1330     1 root     S    49584   5%   0% python message_forwarder.py -f CloudForwarder -c gw.conf
 1306     1 root     S    27032   3%   0% python led_state.py
  709     1 root     S    10412   1%   0% /sbin/udevd -d
  889     1 root     S     9316   1%   0% /usr/sbin/wpa_supplicant -u
 1460     1 root     S     5420   1%   0% /usr/sbin/ofonod
 2635   922 root     S     4908   0%   0% sshd: gwadmin [priv]
  922     1 root     S     4908   0%   0% /usr/sbin/sshd
 1288  1286 root     S     4492   0%   0% perl -nle $|=1; system("rmmod musb-dsps; rmmod musb-hdrc; modprobe musb-hdrc; modprobe musb-dsps") if (/VBUS_ERROR in a_wait_vrise/)
  969     1 nobody   S <   4488   0%   0% /usr/sbin/gpsd -F /var/run/gpsd.sock -P /var/run/gpsd.pid
  933     1 root     S     4384   0%   0% /usr/libexec/bluetooth/bluetoothd
  952     1 avahi    S     3764   0%   0% avahi-daemon: running [Nexturecom-AICN.local]
  953   952 avahi    S     3764   0%   0% avahi-daemon: chroot helper
 2716  2715 gwadmin  S     3412   0%   0% -bash
  859     1 messageb S     3336   0%   0% /usr/bin/dbus-daemon --system
 1275     1 root     S     3088   0%   0% /usr/sbin/crond
 1278  1275 root     S     3088   0%   0% {crond} /usr/sbin/CROND
 1280  1275 root     S     3088   0%   0% {crond} /usr/sbin/CROND
 1281  1275 root     S     3088   0%   0% {crond} /usr/sbin/CROND
  996     1 root     S     2956   0%   0% {mysqld_safe} /bin/sh /usr/bin/mysqld_safe --datadir=/var/lib/mysql --pid-file=/var/lib/mysql/mysqld.pid
 1285  1280 root     S     2824   0%   0% /bin/sh nbiot_connection.sh
 1332     1 root     S     2824   0%   0% {start_getty} /bin/sh /bin/start_getty 115200 ttyO0 vt102
 1286  1281 root     S     2824   0%   0% /bin/sh -c /bin/dmesg -w | perl -nle '$|=1; system("rmmod musb-dsps; rmmod musb-hdrc; modprobe musb-hdrc; modprobe musb-dsps") if (/VBUS_ERROR in a_wait_
  943     1 root     S     2724   0%   0% /sbin/syslogd -n -O /var/log/messages
  946     1 root     S     2724   0%   0% /sbin/klogd -n
 1333     1 root     S     2724   0%   0% /sbin/getty 38400 tty1
 1362  1332 root     S     2724   0%   0% /sbin/getty -L 115200 ttyO0 vt102
 1287  1286 root     S     2184   0%   0% /bin/dmesg -w
 1272     1 root     S     1956   0%   0% /usr/local/bin//gpio-watch 72:both
    1     0 root     S     1716   0%   0% init [5]
 6645  1285 root     S     1716   0%   0% sleep 20
 6665  1283 root     S     1716   0%   0% sleep 1
  153     2 root     IW       0   0%   0% [kworker/u2:2]
Nexturecom-AICN:~$ cat /opt/iotgw/wirepas_adapter.py
'''
    WIREPAS_ADAPTER.PY

   System simulator simulates a network of eChargie nodes. It reads a file listing eChargie node IDs
   and creates a thread for each eChargie

    Copyright (c) 2018, Treon, All rights reserved.
'''
#import threading
import time
import sys
import zmq
import getopt
import ConfigParser
import threading
import Queue
import json
import base64
from wirepas.meshapi import *
from wirepas.meshapicsap import *
import logging
import time

def show_help():
    "Shows simple usage help text"
    print "\n\n wirepas_adapter.py -n <adapter name> -c <conf file> -h -v\n"
    print "    {:30} {}". format("adapter name","Name matching a section in config file.")
    print "    {:30} {}". format("conf file","Gateway configuratio file")
    print "    {:30} {}". format("help","Show help.... that you are right now reading\n")
    print "    {:30} {}". format("verbose","Turn on verbose output\n")

    print("""
    Wirepas adapter connects mesh network to gateway software.
    """)

def setupLogger(loggerName):
    """Debug logger format setup """
    logger = logging.getLogger(loggerName)
    logger.setLevel(logging.INFO)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s','%H:%M:%S')
    #formatter = logging.Formatter('%(asctime)s - %(message)s','%H:%M:%S')
    loghandler = logging.StreamHandler()
    loghandler.setLevel(logging.INFO)
    loghandler.setFormatter(formatter)
    logger.addHandler(loghandler)
    return logger

class InvalidValue(Exception):
    def __init__(self, expr, msg):
        self.expr = expr
        self.msg = msg

class MeshAdapter:
    """Main class for mesh network adapter."""
    NETWORKID_MAX = 0xFFFFFDL
    #ADDRESS_MAX = 0xFFFFFDL
    ADDRESS_MAX = 0xFFFFFFFFL          # Individual node addresses reach only to 0xFFFFFDL but group and broadcast addresses are larger
    CHANNEL_MAX = 27
    EP_MAX = 254
    TREON_EP_LIST = [2,4,6]
    SENSOR_ENDPOINTS = [2,4,6]
    ECHARGIE_ENDPOINTS = [100]
    DIAGNOSTIC_ENDPOINTS = [251,252,253,254]
    MSG_TIMEOUT = 10
    ECHARGIE_TOPIC = "echargie_command"
    NODE_UPDATE_TOPIC = "node_update"
    BITMASK_CBMAC = 0x10
    ROLE_SINK = 0x1

    #Queue for storing messages in rx callback.
    fro_mesh = Queue.Queue()
    t_mesh = Queue.Queue()

    def __init__(self,name,logger):
        self.name = name
        self.network_id = 0
        self.network_ch = 0
        self.node_addr = 0
        self.cipher_key = 0
        self.auth_key = 0
        self.low_latency = True
        self.logger = logging.getLogger("wpLogger")
        self.logger.info("Created adapter: {}".format(name))
        self.active = True      #indicator to threads
        self.pdu_id = 1
        #print("Created adapter: {}".format(name))

        # Mesh message queues and handlers
        self.listener_thread = threading.Thread(target=self.mesh_listener)
        self.inbox_listener_thread = threading.Thread(target=self.inbox_listener)
        #self.sender_thread = threading.Thread(target=self.mesh_sender)

    @staticmethod
    def _data_rx_callback_gen():
        '''
        This is a callback function called when data is received. This should be
        kept very quick and simple!
        '''
        def f(command):
            if command.indication != []:
                MeshAdapter.fro_mesh.put(command)
            else:
                print("Mesh RX cb - empty data received.") #should logger be global class method
        return f

    @staticmethod
    def dump_wp_msg(incoming):
        '''
        Dumps wirepas DsapRX message to simple dict and turns it to json
        wirepas indication values are tuple (value,type string)
        '''
        msg_dict = {}
        msg_dict['src'] = incoming.indication['source_address'][0]
        msg_dict['src_ep'] = incoming.indication['source_endpoint'][0]
        # we are the destination - omit this
        #msg_dict['dest'] = incoming.indication['destination_address'][0]
        msg_dict['dest_ep'] = incoming.indication['destination_endpoint'][0]
        msg_dict['qos'] = incoming.indication['qos'][0]
        msg_dict['travel_time'] = incoming.indication['travel_time'][0]
        #is this needed?
        msg_dict['pdu_len'] = incoming.indication['pdu_length'][0]
        msg_dict['apdu'] = base64.b64encode(incoming.indication['apdu'][0])

        return json.dumps(msg_dict)

    @staticmethod
    def get_apdu_b64(incoming):
        '''
        Returns apdu payload from wirepas message
        '''
        return base64.b64encode(incoming.indication['apdu'][0])

    @staticmethod
    def validate_message(wp_msg):
        '''Check validity of tx wirepas message data'''

        if len(wp_msg['apdu']) == 0:
            raise InvalidValue(len(wp_msg['apdu']),"Empty apdu data.")
        if not (0 <= wp_msg['dest'] <= MeshAdapter.ADDRESS_MAX):
            if wp_msg['dest'] != "BROADCAST":
                raise InvalidValue(wp_msg['dest'],"Destination address is not valid.")
        if not (0 <= wp_msg['src_ep'] <= MeshAdapter.EP_MAX):
            raise InvalidValue(wp_msg['src_ep'],"Source endpoint is not valid.")
        if not (0 <= wp_msg['dest_ep'] <= MeshAdapter.EP_MAX):
            raise InvalidValue(wp_msg['src_ep'],"Destination endpoint is not valid.")
        return True

    def new_pdu_id(self):
        """Increase PDU ID counter for sent wirepas messages"""
        if self.pdu_id == 65534:
            self.pdu_id = 1
        else:
            self.pdu_id = self.pdu_id+1

    def mesh_listener(self):
        """Receives data from mesh network and pushes it upwards to GW stack."""
        self.logger.debug("Starting mesh_listener thread")
        self.sink.register_indication_callback(DsapDataRx(),MeshAdapter._data_rx_callback_gen())
        self.sink.start_data_rx()
        self.logger.debug("mesh_listener started listening rx")
        while self.active:
            dsap_msg = MeshAdapter.fro_mesh.get()
            src_endpoint = dsap_msg.indication['source_endpoint'][0]
            src_addr = dsap_msg.indication['source_address'][0]
            # BUILD ZMQ MESSAGE
            apdu_b64 = self.get_apdu_b64(dsap_msg)
            msg_parts = [str(src_endpoint),str(src_addr),apdu_b64]
            #AND SEND IT
            self.tx_socket.send_multipart(msg_parts)
            self.logger.debug("RX from {}:{} APDU:{}".format(src_addr,src_endpoint,apdu_b64))

    def inbox_listener(self):
        """Listens incoming data from middleware and sends it to mesh."""
        self.logger.debug("Starting inbox_listener thread")
        while self.active:
            try:
                topic,dest_addr,apdu_b64 = self.rx_socket.recv_multipart()
            except Exception as e:
                self.logger.error("inbox_listener recv failed: {}",format(e.message))

            if dest_addr == "BROADCAST":
                destination = "BROADCAST"
            else:
                destination = int(dest_addr)
            msg = {'dest':destination,'apdu':apdu_b64}
            if topic == self.ECHARGIE_TOPIC:
                msg['src_ep'] = 100
                msg['dest_ep'] = 100
            elif topic == self.NODE_UPDATE_TOPIC:
                msg['src_ep'] = 42
                msg['dest_ep'] = 42
            else:  # add other topics, like node condiguration etc. here
                msg['src_ep'] = 43
                msg['dest_ep'] = 43
            self.logger.debug("TX to {}:{} APDU:{}".format(dest_addr,msg['dest_ep'],apdu_b64))
            try:
                self.validate_message(msg)
            except InvalidValue as e:
                self.logger.error("Invalid TX message: {} {}".format(e.msg,e.expr))
                return
            try:
                Res = self.sink.data_tx(
                        data=base64.b64decode(msg['apdu']),
                        pdu_id=self.pdu_id,
                        dest_address=msg['dest'] if (msg['dest'] != "BROADCAST") else ADDRESS_BROADCAST,
                        src_endpoint=msg['src_ep'],
                        dst_endpoint=msg['dest_ep'],
                        Req_tx_ind=False,
                        timeout=MeshAdapter.MSG_TIMEOUT)
                self.logger.debug("TX result: {}".format(Res['result']))
                self.new_pdu_id()
            except Exception as e:
                self.logger.error("Mesh TX failed {}".format(e.message))
            #self.logger.debug("Sent mesh message PDU_ID:{} EP:{} DST:{}".format(self.pdu_id,msg['dest_ep'],msg['dest'] ))

    """
    def mesh_sender(self):

        Sends data from GW stack to mesh network.OBSOLETE

        self.logger.debug("Starting mesh_sender thread")
        while self.active:
            try:
                wp_msg = MeshAdapter.t_mesh.get()
                #build wiraps message here and send it
            except Exception as e:
                self.logger.error("mesh_sender failed: {}",format(e.message))

    """

    def validate(self,test_value, wp_type):
        """ Validate that tested value is in allowed range """
        if wp_type == "NetworkId":
            try:
                result=int(test_value)
            except ValueError:
                try:
                    result=int(test_value,16)
                except ValueError:
                    raise InvalidValue(test_value,"Network id is not integer")
            if not (1 <= result <= MeshAdapter.NETWORKID_MAX):
                raise InvalidValue(test_value,"Network id is out of range")
            else:
                return result
        elif wp_type == "NodeAddress":
            try:
                result=int(test_value)
            except ValueError:
                try:
                    result=int(test_value,16)
                except ValueError:
                    raise InvalidValue(test_value,"Node address is not integer")
            if not (1 <= result <= MeshAdapter.ADDRESS_MAX):
                raise InvalidValue(test_value,"Node address is out of range")
            else:
                return result
        elif wp_type == "NetworkCh":
            try:
                result=int(test_value)
            except ValueError:
                try:
                    result=int(test_value,16)
                except ValueError:
                    raise InvalidValue(test_value,"Network channel is not integer")
            if not (1 <= result <= MeshAdapter.CHANNEL_MAX):
                raise InvalidValue(test_value,"Network channel is out of range")
            else:
                return result

    def configure_sockets(self):
        """Set up communication sockets."""
        self.socketCtx=zmq.Context.instance()
        #socket for sending messages to middleware (UPSTREAM)
        self.tx_socket=self.socketCtx.socket(zmq.PUB)
        self.logger.debug("Connecting to outbound socket {}".format(self.out_socket))
        self.tx_socket.connect(self.out_socket)
        #socket for receiving messages from middleware (DOWNSTREAM)
        self.rx_socket=self.socketCtx.socket(zmq.SUB)
        self.logger.debug("Connecting to inbound socket {}".format(self.in_socket))
        self.rx_socket.connect(self.in_socket)
        self.rx_socket.setsockopt(zmq.SUBSCRIBE,"")  #subscribe all

    def configure_adapter(self,config_fn):
        """Configure mesh adapter values from config file."""
        try:
            self.logger.info("Reading config {}".format(config_fn))
            config=ConfigParser.SafeConfigParser()
            config.read(config_fn)
        except Exception as e:
            self.logger.error("Failed to read config:{}".format(e))
            sys.exit(1)
        try:
            self.mesh_data = config.get(self.name,"MeshData")
            self.mesh_config = config.get(self.name,"MeshConfig")   # Network for configuring new nodes
        except ConfigParser.NoSectionError:
            self.logger.error("Failed to read section:{}".format(self.name))
            sys.exit(1)
        #wirepas parameters
        try:
            self.network_id = self.validate(config.get(self.mesh_data,"NetworkId"),"NetworkId")
            self.node_addr = self.validate(config.get(self.mesh_data,"NodeAddress"),"NodeAddress")
            self.network_ch = self.validate(config.getint(self.mesh_data,"NetworkCh"),"NetworkCh")
            self.low_latency = config.getboolean(self.mesh_data,"LowLatency")
        except InvalidValue as e:
            self.logger.error("{}: {}".format(e.msg,e.expr))
            sys.exit(1)
        except Exception as e:
            self.logger.error("Failed to read section:{}".format(self.mesh_data))
            sys.exit(1)
        #communication sockets
        try:
            self.in_socket = config.get(self.name,"InSocket")
            self.out_socket = config.get(self.name,"OutSocket")
        except Exception as e:
            self.logger.error("Failed to read section:{}".format(self.mesh_data))
            sys.exit(1)

    def start_network(self,network_type):
        """Starts sink in the wirepas network"""
        NETWORK_START_LIMIT = 5
        NETWORK_START_DELAY = 30

        if network_type != "mesh_data":
            self.logger.error("Only mesh_data network is now supported.")
            sys.exit(2)
        self.logger.debug("Initializing wirepas mesh network.")

        self.network = MeshApiNetwork()

        tries = 0
        network_ok = False
        while tries < NETWORK_START_LIMIT:
            tries = tries + 1
            try:
                self.network.find_devices()
                network_ok = True
                break
            except Exception as e:
                self.logger.error("Failed to find wirepas devices: {}".format(e.message))
                self.logger.debug("Waiting {}s before re-try.".format(NETWORK_START_DELAY))
                network_ok = False
                time.sleep(NETWORK_START_DELAY)

        if network_ok == False:
            self.logger.error("Failed toi find wirepas devices after {} tries".format(tries))
            sys.exit(1)

        tries = 0
        network_ok = False
        while tries < NETWORK_START_LIMIT:
            tries = tries + 1
            try:
                self.sink = self.network.get_sinks()[0]
                network_ok = True
                break
            except Exception as e:
                self.logger.error("Failed to find wirepas sink: "+e.message)
                self.logger.debug("Waiting {}s before re-try.".format(NETWORK_START_DELAY))
                network_ok = False
                time.sleep(NETWORK_START_DELAY)

        if network_ok == False:
            self.logger.error("Failed to find wirepas sink after {} tries".format(tries))
            sys.exit(1)

        #Set network parameters
        self.sink.stack_stop()

        tries = 0
        network_ok = False
        while tries < NETWORK_START_LIMIT:
            tries = tries + 1
            try:
                self.sink.set_network_address(self.network_id)
                self.sink.set_network_channel(self.network_ch)
                self.sink.set_address(self.node_addr)
                #role = self.sink.get_role()
                #if self.low_latency:
                #    role = role & MeshAdapter.BITMASK_CBMAC
                #else:
                #    role = role ^ MeshAdapter.BITMASK_CBMAC
                #self.sink.set_role(role)
                network_ok = True
                break
            except Exception:
                self.logger.error("Failed to setwirepas parameters.")
                self.logger.debug("Waiting {}s before re-try.".format(NETWORK_START_DELAY))
                network_ok = False
                time.sleep(NETWORK_START_DELAY)
        if network_ok == False:
            self.logger.error("Failed to set wirepas parameters after {} tries".format(tries))
            sys.exit(1)

        self.logger.info("Starting network 0x{0:X} ({0}) with sink address {1}".format(self.sink.get_network_address(),
        self.sink.get_address()))
        try:
            self.sink.stack_start()
        except Exception as e:
            self.logger.error("Stack start failed: {}".format(e.message))
            sys.exit(2)
        #Network started. Now worker threads can be started
        self.listener_thread.start()
        self.inbox_listener_thread.start()
        #self.sender_thread.start()

def main(argv):
    adapter_name ="WpAdapter"
    config_fn = "gw.conf"

    setupLogger("wpLogger")
    logger = logging.getLogger("wpLogger")
    logger.debug("Starting Wirepas adapter")

    try:
        opts,args = getopt.getopt(argv,"n:c:hv",["name=","config=","help","verbose"])
    except getopt.GetoptError:
        show_help()
        sys.exit(1)
    if len(opts):
        for opt,arg in opts:
            if opt in ("-n","--name"):
                adapter_name = arg
            elif opt in ("-c","--config"):
                config_fn = arg
            elif opt in ("-h","--help"):
                show_help()
                sys.exit(0)
            elif opt in ("-v","--verbose"):
                logger.setLevel(logging.DEBUG)
            else:
                print opt
                assert False, "Unhandled option"

    mesh_connection = MeshAdapter(adapter_name,logger)
    mesh_connection.configure_adapter(config_fn)
    mesh_connection.configure_sockets()
    mesh_connection.start_network("mesh_data")
    mesh_connection.listener_thread.join()

if __name__ == "__main__":
    main(sys.argv[1:])